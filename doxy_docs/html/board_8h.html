<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Domino: board.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Domino
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">board.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="player_8h_source.html">player.h</a>&quot;</code><br />
</div>
<p><a href="board_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_matrix.html">Matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9570374e3dbc873595100dae1e584459" id="r_a9570374e3dbc873595100dae1e584459"><td class="memItemLeft" align="right" valign="top">typedef struct Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9570374e3dbc873595100dae1e584459">Matrix</a></td></tr>
<tr class="separator:a9570374e3dbc873595100dae1e584459"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5bb7a8a8e92acce3fcb400b3c8e3539b" id="r_a5bb7a8a8e92acce3fcb400b3c8e3539b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bb7a8a8e92acce3fcb400b3c8e3539b">newMatrix</a> (int rows, int cols)</td></tr>
<tr class="separator:a5bb7a8a8e92acce3fcb400b3c8e3539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d797f1eca44a420287dd9a3947c96e" id="r_a43d797f1eca44a420287dd9a3947c96e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43d797f1eca44a420287dd9a3947c96e">free_board</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board)</td></tr>
<tr class="separator:a43d797f1eca44a420287dd9a3947c96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ab112764167d32e08f3c9d8a7fc42c" id="r_a91ab112764167d32e08f3c9d8a7fc42c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91ab112764167d32e08f3c9d8a7fc42c">switch_tile</a> (<a class="el" href="struct_tile.html">Tile</a> *x)</td></tr>
<tr class="separator:a91ab112764167d32e08f3c9d8a7fc42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303a627e4ba296b5e8ea415c74b5a7b9" id="r_a303a627e4ba296b5e8ea415c74b5a7b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a303a627e4ba296b5e8ea415c74b5a7b9">select_mode</a> (void)</td></tr>
<tr class="separator:a303a627e4ba296b5e8ea415c74b5a7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c857fd0dcd55217d95f289f12ef0e6e" id="r_a1c857fd0dcd55217d95f289f12ef0e6e"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c857fd0dcd55217d95f289f12ef0e6e">initboard</a> (int rows, int cols)</td></tr>
<tr class="separator:a1c857fd0dcd55217d95f289f12ef0e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa0239b7755a1de1360570d098e5a43" id="r_a3aa0239b7755a1de1360570d098e5a43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aa0239b7755a1de1360570d098e5a43">print_board</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board)</td></tr>
<tr class="separator:a3aa0239b7755a1de1360570d098e5a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2f0668482407dcc36c58262d0727f7" id="r_adf2f0668482407dcc36c58262d0727f7"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf2f0668482407dcc36c58262d0727f7">tile_to_vertical</a> (<a class="el" href="struct_tile.html">Tile</a> t)</td></tr>
<tr class="separator:adf2f0668482407dcc36c58262d0727f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15f9f890a419d2eea86e1f7b2f43afd" id="r_ac15f9f890a419d2eea86e1f7b2f43afd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac15f9f890a419d2eea86e1f7b2f43afd">tile_to_horizontal</a> (<a class="el" href="struct_tile.html">Tile</a> t)</td></tr>
<tr class="separator:ac15f9f890a419d2eea86e1f7b2f43afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37f9cbe06f2e7203172e4f37b8c0a07" id="r_aa37f9cbe06f2e7203172e4f37b8c0a07"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa37f9cbe06f2e7203172e4f37b8c0a07">select_pos</a> (void)</td></tr>
<tr class="separator:aa37f9cbe06f2e7203172e4f37b8c0a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c0686199549915ef2d6663a8f4d8dc" id="r_aa2c0686199549915ef2d6663a8f4d8dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2c0686199549915ef2d6663a8f4d8dc">insert_right</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> tile)</td></tr>
<tr class="separator:aa2c0686199549915ef2d6663a8f4d8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2548a0007bdba02dce7a97debf511994" id="r_a2548a0007bdba02dce7a97debf511994"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2548a0007bdba02dce7a97debf511994">insert_left</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> tile)</td></tr>
<tr class="separator:a2548a0007bdba02dce7a97debf511994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b579a3bbf32552685e542de411758bd" id="r_a2b579a3bbf32552685e542de411758bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b579a3bbf32552685e542de411758bd">insert_left_2D</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> tile)</td></tr>
<tr class="separator:a2b579a3bbf32552685e542de411758bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693bd885b4ddc8a19a1d3f49eac85cdb" id="r_a693bd885b4ddc8a19a1d3f49eac85cdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a693bd885b4ddc8a19a1d3f49eac85cdb">insert_right_2D</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> tile)</td></tr>
<tr class="separator:a693bd885b4ddc8a19a1d3f49eac85cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db5c0c204bac8d59304f4e3bb2ade02" id="r_a7db5c0c204bac8d59304f4e3bb2ade02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7db5c0c204bac8d59304f4e3bb2ade02">get_score</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board)</td></tr>
<tr class="separator:a7db5c0c204bac8d59304f4e3bb2ade02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a8a953a4d501a57a0c16ad5d90a05f" id="r_ab7a8a953a4d501a57a0c16ad5d90a05f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7a8a953a4d501a57a0c16ad5d90a05f">available_moves_linear</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> *deck, int deck_size, int n)</td></tr>
<tr class="separator:ab7a8a953a4d501a57a0c16ad5d90a05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a512878b4f3d6c3ba044a4422507bb5" id="r_a7a512878b4f3d6c3ba044a4422507bb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a512878b4f3d6c3ba044a4422507bb5">end_game</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board)</td></tr>
<tr class="separator:a7a512878b4f3d6c3ba044a4422507bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac654f4dce8de976d25e8844dd5d9bb0" id="r_aac654f4dce8de976d25e8844dd5d9bb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac654f4dce8de976d25e8844dd5d9bb0">print_screen</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> *deck, int decksize)</td></tr>
<tr class="separator:aac654f4dce8de976d25e8844dd5d9bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48dcab6c9ecf039e85af529f2d686e7" id="r_ae48dcab6c9ecf039e85af529f2d686e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae48dcab6c9ecf039e85af529f2d686e7">first_empty</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board)</td></tr>
<tr class="separator:ae48dcab6c9ecf039e85af529f2d686e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368a485bcb02f8ec0d6d1ba44b7b7017" id="r_a368a485bcb02f8ec0d6d1ba44b7b7017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a368a485bcb02f8ec0d6d1ba44b7b7017">find_blank</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, int *row, int *col)</td></tr>
<tr class="separator:a368a485bcb02f8ec0d6d1ba44b7b7017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30943231bb031a1db095e51c458c846" id="r_ad30943231bb031a1db095e51c458c846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad30943231bb031a1db095e51c458c846">find_blank_left</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, int *row, int *col)</td></tr>
<tr class="separator:ad30943231bb031a1db095e51c458c846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9838cf421f6f04ca69744cf9dc5f9e4" id="r_ad9838cf421f6f04ca69744cf9dc5f9e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9838cf421f6f04ca69744cf9dc5f9e4">count_blank</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, int i, int j)</td></tr>
<tr class="separator:ad9838cf421f6f04ca69744cf9dc5f9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131d9135e2a81963a798bbcd70528fbc" id="r_a131d9135e2a81963a798bbcd70528fbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a131d9135e2a81963a798bbcd70528fbc">check_blank</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, int i, int j, char orientation)</td></tr>
<tr class="separator:a131d9135e2a81963a798bbcd70528fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a239e5586e9ca513f40cbbc4a1aff24" id="r_a4a239e5586e9ca513f40cbbc4a1aff24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a239e5586e9ca513f40cbbc4a1aff24">check_blank_left</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, int i, int j, char orientation)</td></tr>
<tr class="separator:a4a239e5586e9ca513f40cbbc4a1aff24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fefbd33f2f2ad26d18fc9d0b925931" id="r_ae5fefbd33f2f2ad26d18fc9d0b925931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5fefbd33f2f2ad26d18fc9d0b925931">copy_board</a> (<a class="el" href="struct_matrix.html">Matrix</a> *destination, <a class="el" href="struct_matrix.html">Matrix</a> *source)</td></tr>
<tr class="separator:ae5fefbd33f2f2ad26d18fc9d0b925931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292c3e64b265f60dfee211ca25a77522" id="r_a292c3e64b265f60dfee211ca25a77522"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a292c3e64b265f60dfee211ca25a77522">available_moves_2D</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> *deck, int remain, int n)</td></tr>
<tr class="separator:a292c3e64b265f60dfee211ca25a77522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a1126377461cde912832c6735e42d6" id="r_a90a1126377461cde912832c6735e42d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90a1126377461cde912832c6735e42d6">select_autoplay</a> (void)</td></tr>
<tr class="separator:a90a1126377461cde912832c6735e42d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f65a879f21b9d434de6aeecc32da60" id="r_a83f65a879f21b9d434de6aeecc32da60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83f65a879f21b9d434de6aeecc32da60">autoplay</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> *deck, int remain, int n, int mode)</td></tr>
<tr class="separator:a83f65a879f21b9d434de6aeecc32da60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3157d1768611246cc12d70b133fdea9" id="r_aa3157d1768611246cc12d70b133fdea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3157d1768611246cc12d70b133fdea9">plus_one</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board)</td></tr>
<tr class="separator:aa3157d1768611246cc12d70b133fdea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff5ef337c70677d9e8f8e2290e674b3" id="r_a0ff5ef337c70677d9e8f8e2290e674b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ff5ef337c70677d9e8f8e2290e674b3">move_board</a> (<a class="el" href="struct_matrix.html">Matrix</a> *board, int mode)</td></tr>
<tr class="separator:a0ff5ef337c70677d9e8f8e2290e674b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9570374e3dbc873595100dae1e584459" name="a9570374e3dbc873595100dae1e584459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9570374e3dbc873595100dae1e584459">&#9670;&#160;</a></span>Matrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct Matrix Matrix</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>struct utilizzata per la rappresentazione e gestione del tavolo di gioco </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a83f65a879f21b9d434de6aeecc32da60" name="a83f65a879f21b9d434de6aeecc32da60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f65a879f21b9d434de6aeecc32da60">&#9670;&#160;</a></span>autoplay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void autoplay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_tile.html">Tile</a> *</td>          <td class="paramname"><span class="paramname"><em>deck</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>remain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: void</p>
<p>Parametri:</p><ul>
<li><a class="el" href="struct_matrix.html">Matrix</a> *board: tavolo di gioco.</li>
<li><a class="el" href="struct_tile.html">Tile</a> *deck: tessere nella mano del giocatore</li>
<li>int remain: dimensione effettiva del deck del giocatore</li>
<li>int n: dimensione iniziale del deck del giocatore</li>
<li>int mode: variabile che identifica la tipologia di partita (Lineare/2D)</li>
</ul>
<p>Funzione che implementa la modalità IA del gioco. Se la variabile mode==1 allora verrà giocata una partita in Domino Lineare, altrimenti la partita sarà in Domino 2D.</p>
<ul>
<li>Domino Lineare: dentro ad un ciclo while che nella condizione controlla che ci siano tessere rimanenti nella mano del giocatore, che la variabile di scorrimento delle tessere nel deck non superi la dimensione effettiva del deck e che siano ancora disponibili mosse in modalità lineare (tramite <a class="el" href="#ab7a8a953a4d501a57a0c16ad5d90a05f">available_moves_linear()</a>), la funzione prova l'inserimento di una tessera del deck alla volta. Data la tessera [xy] verrà effettuato un inserimento di [xy] sia a destra che a sinistra. nel caso nessuno dei due vada a buon fine verrà provato l'inserimento a destra e a sinistra della stessa tessera ma con i valori scambiati [yx]. Il caso nessuno dei tentativi su una data tessera vada a buon fine , verrà "estratta" la tessera successiva e così via. Se la tessera viene inserita con successo, il tentativo di inserimento successivo ricomincerà dalla prima tessera del deck. Nel caso in cui nessuna tessera venga inserita con successo. La funzione termina. L'esecuzione ritorna alla funzione main e viene dichiarato il "game over"</li>
<li>Domino 2D: il procedimento è lo stesso di autoplay con modalità Lineare. Tuttavia per ogni tessera [xy] verrà eseguito tentativo di inserimento sia su [xy] che su [yx] in orizzontale a destra, in orizzontale a sinistra, in verticale a destra, in verticale a sinistra. </li>
</ul>

</div>
</div>
<a id="a292c3e64b265f60dfee211ca25a77522" name="a292c3e64b265f60dfee211ca25a77522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292c3e64b265f60dfee211ca25a77522">&#9670;&#160;</a></span>available_moves_2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool available_moves_2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_tile.html">Tile</a> *</td>          <td class="paramname"><span class="paramname"><em>deck</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>remain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: bool</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> *deck, int remain, int n</p>
<p>La funzione dapprima controlla se il deck è ancora composto da tutte le n tessere assegnate al giocatore ad inizio partita, se sì ritorna true, altrimenti verifica l'esistenza di mosse disponibili creando una <a class="el" href="struct_matrix.html">Matrix</a> copy con una copia del tavolo di gioco grazie a <a class="el" href="#ae5fefbd33f2f2ad26d18fc9d0b925931">copy_board()</a>. Su <a class="el" href="struct_matrix.html">Matrix</a> copy vengono poi "provate" le funzioni <a class="el" href="#a2b579a3bbf32552685e542de411758bd">insert_left_2D()</a> ed <a class="el" href="#a693bd885b4ddc8a19a1d3f49eac85cdb">insert_right_2D()</a> utilizzando una tessera alla volta tra quelle ancora nel deck del giocatore. se una delle funzioni di inserimento su una tessera ritorna true allora anche available_moves_2D ritorna true. Se per una data tessera nessuna delle chiamate alle fuzioni di inserimento ritorna true, viene ripetuto il tentativo sulla tessera successiva nel deck. Se vengono provate tutte le tessere del deck senza successo la funzione ritorna false e manda la partita in "game over". </p>

</div>
</div>
<a id="ab7a8a953a4d501a57a0c16ad5d90a05f" name="ab7a8a953a4d501a57a0c16ad5d90a05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a8a953a4d501a57a0c16ad5d90a05f">&#9670;&#160;</a></span>available_moves_linear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool available_moves_linear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_tile.html">Tile</a> *</td>          <td class="paramname"><span class="paramname"><em>deck</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>deck_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: bool</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> *deck, int deck_size, int n;</p><ul>
<li><a class="el" href="struct_tile.html">Tile</a> *deck: puntatore alla mano di tessere del giocatore</li>
<li>int deck_size: dimensione del deck al momento della chiamata a funzione. man mano che la partita procede, deck_size diminuisce.</li>
<li>int n: dimensione del deck del giocatore all'inizio della partita</li>
</ul>
<p>In modalità di gioco Domino Lineare, nel caso in cui non sia stata ancora giocata nessuna tesserea, restituisce true perchè è sicuramente possibile fare una mossa su tavolo di gioco vuoto. Altrimenti, andando a prendere una alla volta le tessere rimaste nella mano del giocatore:</p>
<ul>
<li>se la tessera è una tessera speciale [+1][MR][00] resituisce true perchè sicuramente è possibile una mossa con quelle tessere</li>
<li>se la tessera è una tessera normale numerica [xy] controlla se ultimo numero a destra sulla board è ==x oppure 0, oppure se il primo numero a sinistra sulla board sia ==y oppure 0.</li>
</ul>
<p>Se nessuno dei controlli è valido, ripete sulla tessera successiva e in caso siano state provate tutte le tessere senza successo, la funzione ritorna false e manda il gioco in "game over". </p>

</div>
</div>
<a id="a131d9135e2a81963a798bbcd70528fbc" name="a131d9135e2a81963a798bbcd70528fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131d9135e2a81963a798bbcd70528fbc">&#9670;&#160;</a></span>check_blank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool check_blank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: bool</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board</p><ul>
<li>int i: indice di riga</li>
<li>int j: indice di colonna</li>
<li>char orientation: char che indica l'orientamento della tessera che va inserita (Orizzontale/Verticale)</li>
</ul>
<p>Funzione che controlla per le funzioni di <a class="el" href="#aa2c0686199549915ef2d6663a8f4d8dc">insert_right()</a> ed insert_right_2D, se ci sono abbastanza celle libere a partire dalla posizione board-&gt;m[i][j] per posizionare la nuova tessera.</p>
<ul>
<li>Se la tessera va inserita in orizzontale (orientation=='O') viene controllato che da board-&gt; m[i][j] in poi ci siano 4 char == ' '</li>
<li>Se la tessera va inserita in verticale controlla che a partire da m[i][j] ci siano 2 char ==' ' ed esegue lo stesso controllo anche in riga i+1</li>
</ul>
<p>Ritorna True se lo spazio su board-&gt;m è sufficiente, False altrimenti. </p>

</div>
</div>
<a id="a4a239e5586e9ca513f40cbbc4a1aff24" name="a4a239e5586e9ca513f40cbbc4a1aff24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a239e5586e9ca513f40cbbc4a1aff24">&#9670;&#160;</a></span>check_blank_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool check_blank_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>orientation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: bool</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board</p><ul>
<li>int i: indice di riga</li>
<li>int j: indice di colonna</li>
<li>char orientation: char che indica l'orientamento della tessera che va inserita (Orizzontale/Verticale)</li>
</ul>
<p>Funzione che controlla per le funzioni di <a class="el" href="#a2548a0007bdba02dce7a97debf511994">insert_left()</a> ed inser_left_2D, se ci sono abbastanza celle libere a partire prima della posizione board-&gt;m[i][j] per posizionare la nuova tessera.</p>
<ul>
<li>Se la tessera va inserita in orizzontale (orientation == 'O') viene controllato che le 4 celle prima di board-&gt;m[i][j] siano tutte uguali a ' '.</li>
<li>Se la tessera va inserita in verticale controlla che le 2 celle prima della cella board-&gt;m[i][j] e le due celle prima della cella board-&gt;m[i+1][j] siano tutte uguali a ' '.</li>
</ul>
<p>Ritorna True se lo spazio su board-&gt;m è sufficiente, False altrimenti. </p>

</div>
</div>
<a id="ae5fefbd33f2f2ad26d18fc9d0b925931" name="ae5fefbd33f2f2ad26d18fc9d0b925931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fefbd33f2f2ad26d18fc9d0b925931">&#9670;&#160;</a></span>copy_board()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy_board </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: void</p>
<p>Parametri:</p><ul>
<li><a class="el" href="struct_matrix.html">Matrix</a> *source: oggetto che verrà copiato</li>
<li><a class="el" href="struct_matrix.html">Matrix</a> *destination: oggetto in cui verrà copiato source.</li>
</ul>
<p>La funzione esegue due cicli for innestati per copiare source-&gt;m dentro a destination-&gt;m. </p>

</div>
</div>
<a id="ad9838cf421f6f04ca69744cf9dc5f9e4" name="ad9838cf421f6f04ca69744cf9dc5f9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9838cf421f6f04ca69744cf9dc5f9e4">&#9670;&#160;</a></span>count_blank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int count_blank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: int</p>
<p>Parametri:</p><ul>
<li><a class="el" href="struct_matrix.html">Matrix</a> *board</li>
<li>int i: indice della riga su cui sta per essere eseguita l'ispezione</li>
<li>int j: indice della riga su cui sta per essere eseguita l'ispezione</li>
</ul>
<p>La funzione conta dalla cella j, decrementando j di un 1 ogni volta, quante sono le celle libere (' ') sulla riga i, prima della cella board-&gt;m[i][j]. Utilizzata in <a class="el" href="#a2b579a3bbf32552685e542de411758bd">insert_left_2D()</a> nel caso la board debba essere shiftata per permettere l' inserimento di una tessera ad inizio riga e le celle ' ' già presenti non siano sufficienti ad ospitare tutta la tessera </p>

</div>
</div>
<a id="a7a512878b4f3d6c3ba044a4422507bb5" name="a7a512878b4f3d6c3ba044a4422507bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a512878b4f3d6c3ba044a4422507bb5">&#9670;&#160;</a></span>end_game()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void end_game </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: void</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board</p>
<p>richiama la funzione <a class="el" href="#a3aa0239b7755a1de1360570d098e5a43">print_board()</a>, informa il giocatore di non avere più mosse disponibili e stampa il punteggio finale con <a class="el" href="#a7db5c0c204bac8d59304f4e3bb2ade02">get_score()</a> </p>

</div>
</div>
<a id="a368a485bcb02f8ec0d6d1ba44b7b7017" name="a368a485bcb02f8ec0d6d1ba44b7b7017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368a485bcb02f8ec0d6d1ba44b7b7017">&#9670;&#160;</a></span>find_blank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_blank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: void</p>
<p>Parametri:</p><ul>
<li><a class="el" href="struct_matrix.html">Matrix</a> *board: tavolo di gioco in uso</li>
<li>int *row: variabile su cui verrà salvato l'indice della riga in cui è stato trovato un possibile spazio vuoto per l'inserimento di una tessera</li>
<li>int *col:variabile su cui verrà salvato l'indice della colonna in cui è stato trovato un possibile spazio vuoto per l'inserimento di una tessera</li>
</ul>
<p>La funzione scorre con due cicli while innestati il tavolo di gioco board-&gt;m e cerca una cella ' ' valida per possibile inserimento di tessera per le funzioni <a class="el" href="#aa2c0686199549915ef2d6663a8f4d8dc">insert_right()</a> e <a class="el" href="#a693bd885b4ddc8a19a1d3f49eac85cdb">insert_right_2D()</a>. Quando la funzione viene chiamata la prima volta ricere row e col impostati a 0:</p>
<ul>
<li>Se row e col sono impostati a zero e la funzione <a class="el" href="#ae48dcab6c9ecf039e85af529f2d686e7">first_empty()</a> ritorna true allora la funzione lascia row e col invariati e indica che la board è vuota.</li>
</ul>
<p>-Altrimenti appena trova una cella contenente ' ' a destra di una cella != ' ' ritorna row e col della cella contenente ' '. </p>

</div>
</div>
<a id="ad30943231bb031a1db095e51c458c846" name="ad30943231bb031a1db095e51c458c846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30943231bb031a1db095e51c458c846">&#9670;&#160;</a></span>find_blank_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_blank_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: void</p>
<p>Parametri:</p><ul>
<li><a class="el" href="struct_matrix.html">Matrix</a> *board: tavolo di gioco in uso</li>
<li>int *row: variabile su cui verrà salvato l'indice della riga in cui è stato trovato un possibile spazio vuoto per l'inserimento di una tessera</li>
<li>int *col:variabile su cui verrà salvato l'indice della colonna in cui è stato trovato un possibile spazio vuoto per</li>
</ul>
<p>Esegue gli stessi controlli di <a class="el" href="#a368a485bcb02f8ec0d6d1ba44b7b7017">find_blank()</a>. se *row e *col sono entrambi 0 e la prima riga è tutta vuota (<a class="el" href="#ae48dcab6c9ecf039e85af529f2d686e7">first_empty()</a>) restitisce *row e *col altrimenti ricerca uno spazio vuoto esattamente prima di una cella diversa da ' '. </p>

</div>
</div>
<a id="ae48dcab6c9ecf039e85af529f2d686e7" name="ae48dcab6c9ecf039e85af529f2d686e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48dcab6c9ecf039e85af529f2d686e7">&#9670;&#160;</a></span>first_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool first_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: bool</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board</p>
<p>Controlla se tutta la prima riga della board è vuota. </p>

</div>
</div>
<a id="a43d797f1eca44a420287dd9a3947c96e" name="a43d797f1eca44a420287dd9a3947c96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d797f1eca44a420287dd9a3947c96e">&#9670;&#160;</a></span>free_board()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_board </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: void</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board</p>
<p>In un ciclo for sulle righe di board-&gt;m esegue la free di ogni riga di tipo char* e a fine ciclo esegue la free della struttura stessa. </p>

</div>
</div>
<a id="a7db5c0c204bac8d59304f4e3bb2ade02" name="a7db5c0c204bac8d59304f4e3bb2ade02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db5c0c204bac8d59304f4e3bb2ade02">&#9670;&#160;</a></span>get_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_score </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: int</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board</p>
<p>La funzione scorre tutto il tavolo di gioco e somma riga per riga i numeri delle tessere posizionate. Restituisce il totale che rappresenta il punteggio accumulato fino a quel momento della partita. </p>

</div>
</div>
<a id="a1c857fd0dcd55217d95f289f12ef0e6e" name="a1c857fd0dcd55217d95f289f12ef0e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c857fd0dcd55217d95f289f12ef0e6e">&#9670;&#160;</a></span>initboard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** initboard </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>init_board(int rows, int cols)</p>
<p>Tipo: char** -&gt; all'interno della struct <a class="el" href="struct_matrix.html">Matrix</a> utilizzata per il tavolo di gioco, viene salavato il campo char** board e ad inizio partità il campo viene solamente dichiarato, una volta selezionato il numero di tessere, board viene ridimensionata in base al numero di tessere nella mano del giocatore.</p>
<p>parametri: int rows, int cols.</p>
<ul>
<li>Domino Lineare: per le partite in questa modalità in numero di righe sarà sempre pari ad 1, le tessere vengono utilizzate solo in orizzontale. Per quanto riguarda le colonne invece, essendo ogni tessera rappresentata da 4 char, viene impostata come lunghezza 4*n dove n rappresenta il numero di carte con cui si è iniziata la partita.</li>
<li>Domino 2D: in questa modalità le tessere possono essere utilizzate sia in orizzontale che in verticale. quindi viene impostato come numero di righe 2*n (una tessera in verticale occuperà 2 char in altezza) e 4*n colonne.</li>
</ul>
<p>Dopo aver fatto la malloc per dare la dimensione al tavolo di gioco, tutte le celle vengono inizializzate con un blank ' '. </p>

</div>
</div>
<a id="a2548a0007bdba02dce7a97debf511994" name="a2548a0007bdba02dce7a97debf511994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2548a0007bdba02dce7a97debf511994">&#9670;&#160;</a></span>insert_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool insert_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_tile.html">Tile</a></td>          <td class="paramname"><span class="paramname"><em>tile</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: bool</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> tile</p>
<p>Esegue gli stessi controlli di <a class="el" href="#aa2c0686199549915ef2d6663a8f4d8dc">insert_right()</a> però, se i controlli sulla tessera sono validi e può effettivamente essere inserita, in caso la tessera sia diversa dalla tessera speciale [+1], il campo da gioco viene spostato verso destra con la funzione <a class="el" href="#a0ff5ef337c70677d9e8f8e2290e674b3">move_board()</a> così da non sovrascriverlo. </p>

</div>
</div>
<a id="a2b579a3bbf32552685e542de411758bd" name="a2b579a3bbf32552685e542de411758bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b579a3bbf32552685e542de411758bd">&#9670;&#160;</a></span>insert_left_2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool insert_left_2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_tile.html">Tile</a></td>          <td class="paramname"><span class="paramname"><em>tile</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: bool</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> tile</p>
<p>Per la tessera speciale [+1] viene richiamata la funzione <a class="el" href="#aa3157d1768611246cc12d70b133fdea9">plus_one()</a>. Altrimenti in base al verso in cui si vuole inserire la tessera (orizzontale/verticale, salvato come campo orientation in <a class="el" href="struct_tile.html">Tile</a>) la funzione verrà eseguita sul corrispondente ramo di if-else nel quale verranno richiamate rispettivamente <a class="el" href="#ac15f9f890a419d2eea86e1f7b2f43afd">tile_to_horizontal()</a> o <a class="el" href="#adf2f0668482407dcc36c58262d0727f7">tile_to_vertical()</a>. Entrambi i rami eseguono un ciclo while per la ricerca di una posizione disponibile per l'inserimento della tessera tramite <a class="el" href="#ad30943231bb031a1db095e51c458c846">find_blank_left()</a>.</p>
<ul>
<li>Tessera da posizionare in ORIZZONTALE: se l'inserimento viene fatto a ridosso del lato sinistro del tavolo di gioco, quest'ultimo verrà spostato verso destra con la funzione <a class="el" href="#a0ff5ef337c70677d9e8f8e2290e674b3">move_board()</a>. Altrimenti, con la possibilità che la tessera venga inserita in uno spazio libero tra altre due tessere, vengono fatti controlli sia sul numero sinistro della tessera a cui sta per essere attaccata quella nuova, sia sulla cella a destra dello spazio dove sta per essere attaccata.</li>
<li>Tessera da posizionare in VERTICALE: allo stesso modo dell'inserimento in orizzontale, dato lo spazio disponibile per il possibile inserimento, verranno controllati la compatibilità del numero della tessera alla sua destra ma anche la compatibilità a sinistra dello spazio libero. Da che la tessera viene inserita in verticale, verranno eseguiti gli stessi controlli anche per la riga sottostante dove verrà posizionata la seconda parte della tessera.</li>
</ul>
<p>Viene ritornato un valore booleano che funge da guida per la funzione main per sapere se la tessera è stata inserita e quindi rimuovere la tessera dal deck del giocatore oppure se la tessera non rispetta le condizioni e quindi non è stata inserita. </p>

</div>
</div>
<a id="aa2c0686199549915ef2d6663a8f4d8dc" name="aa2c0686199549915ef2d6663a8f4d8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c0686199549915ef2d6663a8f4d8dc">&#9670;&#160;</a></span>insert_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool insert_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_tile.html">Tile</a></td>          <td class="paramname"><span class="paramname"><em>tile</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: bool</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> tile</p>
<p>Funzione utilizzata per l'inserimento di una tessera a destra sul tavolo di gioco in modalità Domino Lineare. Viene impostata variabiel bool ok a false che viene cambiata a true solo dopo aver effettivamente inserito la tessera sul campo da gioco. un ciclo while incrementa la variabile i utilizzata come contatore fino quando non trova una cella della board contenente uno spazio ' ' per sapere la posizione in cui iniziare a posizionare la tessera sulla board.</p>
<ul>
<li>Prima sezione: controlla se la tessera da inserire è una tessera speciale [MR] e se è già stata inserita almeno un'altra tessera sul campo di gioco (i&gt;3). In caso le condizioni siano valide, la tessera viene inserita e come da specifica, la nuova tessera inserita avrà caratteri uguali ma specchiati rispetto alla tessera a cui si sta attaccando. [12][MR] -&gt; [12][21].</li>
<li>Seconda sezione: controlla se la tessera è una tessera speciale (+1) e che sia già stata inserita almeno uno tessera ed in caso positivo, richiama la funzione <a class="el" href="#aa3157d1768611246cc12d70b133fdea9">plus_one()</a> sulla board.</li>
<li>Terza sezione: controllo se la tessera è la prima che stiamo inserendo, se la tessera è tessera speciale [00] oppure se il carattere sinistro della tessera che stiamo aggiungendo è compatibile con il carattere destro della tessera a cui si sta attaccando ed in caso positivo esegue l'inserimento.</li>
</ul>
<p>la funzione ritorna il valore della variabile booleana ok che viene utilizzata come guida nella funzione main per sapere se la tessera è stata correttamente inserita o meno </p>

</div>
</div>
<a id="a693bd885b4ddc8a19a1d3f49eac85cdb" name="a693bd885b4ddc8a19a1d3f49eac85cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693bd885b4ddc8a19a1d3f49eac85cdb">&#9670;&#160;</a></span>insert_right_2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool insert_right_2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_tile.html">Tile</a></td>          <td class="paramname"><span class="paramname"><em>tile</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: bool</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board, <a class="el" href="struct_tile.html">Tile</a> tile</p>
<p>Alla stessa maniera di <a class="el" href="#a2b579a3bbf32552685e542de411758bd">insert_left_2D()</a> ricerca su ciclo while un posto disponibile per l'inserimento della tessera in verticale o orizzontale. Esegue i controlli di compatibilità sia a destra che a sinistra dello spazio disponibile e nel caso in cui la tessera debba essere posta in verticale controlla su tutte due le righe dove avverrà l'inserimento. Viene eseguito anche controllo di inserimento non out-of-bound della riga. </p>

</div>
</div>
<a id="a0ff5ef337c70677d9e8f8e2290e674b3" name="a0ff5ef337c70677d9e8f8e2290e674b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff5ef337c70677d9e8f8e2290e674b3">&#9670;&#160;</a></span>move_board()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void move_board </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: void</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board</p><ul>
<li>int mode: variabile che identifica il numero di celle di cui è necessario "spostare" il campo di gioco</li>
</ul>
<p>Se mode==1: l'intero campo di gioco verrà ricopiato spostato di 4 char verso destra. Utilizzato quando va inserita una tessera in orizzontale ad inizio di una riga</p>
<p>Se mode==2 (ramo else): l'intero campo di gioco verrà ricopiato spostato di 2 char verso destra. Utilizzato quando va inserita una tessera in verticale a sinistra del campo di gioco oppure quando va inserita una tessera in orizzontale ma le celle ' ' sono solamente 2 quindi sono necessarie altre 2 celle vuote per inserire la tessera. </p>

</div>
</div>
<a id="a5bb7a8a8e92acce3fcb400b3c8e3539b" name="a5bb7a8a8e92acce3fcb400b3c8e3539b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb7a8a8e92acce3fcb400b3c8e3539b">&#9670;&#160;</a></span>newMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_matrix.html">Matrix</a> newMatrix </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: <a class="el" href="struct_matrix.html">Matrix</a></p>
<p>Parametri: int rows, int cols</p>
<p>Creazione di un nuovo oggetto di tipo struct <a class="el" href="struct_matrix.html">Matrix</a> i cui campi avranno come valore i valori passati alla funzione come parametri. Creazione e malloc nuovo array char** m tramite init_board() </p>

</div>
</div>
<a id="aa3157d1768611246cc12d70b133fdea9" name="aa3157d1768611246cc12d70b133fdea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3157d1768611246cc12d70b133fdea9">&#9670;&#160;</a></span>plus_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plus_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: void</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board</p>
<p>La funzione scorre tutta board-&gt;m con due cicli for innestati e incrementa di uno i valori di tutte le tessere sul campo da gioco tranne le tessere [00]. Per i numeri da 1 a 5 il numero viene incrementato di 1. Il numero 6 viene invece portato ad 1. </p>

</div>
</div>
<a id="a3aa0239b7755a1de1360570d098e5a43" name="a3aa0239b7755a1de1360570d098e5a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa0239b7755a1de1360570d098e5a43">&#9670;&#160;</a></span>print_board()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_board </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="#a3aa0239b7755a1de1360570d098e5a43">print_board(Matrix* board)</a></p>
<p>Tipo: void</p>
<p>parametri: <a class="el" href="struct_matrix.html">Matrix</a> *board</p>
<p>Viene preso in input l'oggetto board contente: il tavolo di gioco utilizzato (char** m), il numero di righe ed il numero di colonne e viene stampato il contenuto del tavolo da gioco con le tessere posizionate fino a quel momento </p>

</div>
</div>
<a id="aac654f4dce8de976d25e8844dd5d9bb0" name="aac654f4dce8de976d25e8844dd5d9bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac654f4dce8de976d25e8844dd5d9bb0">&#9670;&#160;</a></span>print_screen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_screen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_matrix.html">Matrix</a> *</td>          <td class="paramname"><span class="paramname"><em>board</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_tile.html">Tile</a> *</td>          <td class="paramname"><span class="paramname"><em>deck</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>decksize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: void</p>
<p>Parametri: <a class="el" href="struct_matrix.html">Matrix</a> <em>board, <a class="el" href="struct_tile.html">Tile</a></em> deck, int decksize</p>
<p>Esegue una clear su terminale e stampa la schermata di gioco richiamando <a class="el" href="#a7db5c0c204bac8d59304f4e3bb2ade02">get_score()</a>, <a class="el" href="#a3aa0239b7755a1de1360570d098e5a43">print_board()</a> e <a class="el" href="player_8c.html#a5f3859b7c5b6436e7e10d21bfa3f763a">print_hand()</a> </p>

</div>
</div>
<a id="a90a1126377461cde912832c6735e42d6" name="a90a1126377461cde912832c6735e42d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a1126377461cde912832c6735e42d6">&#9670;&#160;</a></span>select_autoplay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool select_autoplay </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: bool</p>
<p>Parametri: nessuno</p>
<p>La funzione serve a far selezionare al giocatore se iniziare una partita Interattiva oppure giocata in autonomia "dal computer". Se il giocatore manda in input da tastiera 1 allora verrà restituito false alla funzione <a class="el" href="main_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a> che inizierà una partita interattiva. Se il giocatore manda in input da tastiera 2 allora il valore true verrà restituito alla funzione main che farà cominciare una partita giocata da IA. Qualiasi altro valore in input verrà interpretato come un errore e richiederà il rinserimento dell'input da parte del giocatore </p>

</div>
</div>
<a id="a303a627e4ba296b5e8ea415c74b5a7b9" name="a303a627e4ba296b5e8ea415c74b5a7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303a627e4ba296b5e8ea415c74b5a7b9">&#9670;&#160;</a></span>select_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int select_mode </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="#a303a627e4ba296b5e8ea415c74b5a7b9">select_mode()</a>:</p>
<p>Tipo: int</p>
<p>Parametri: nessuno</p>
<p>Viene chiesto al giocatore di dare in input da tastiera o 1(Domino Lineare) o 2 (Domino 2D). variabile int x impostata inizialmente a -1 e viene eseguito un ciclo while all'interno del quale eseguendo scanf viene assegnato ad x il valore ricevuto in input da tastiera. Fino a quando x non avrà uno dei due valori previsti (1/2), viene richiesto il rinserimento da tastiera dell'input. Per esperienza di gioco più pulita prima del return viene eseguita una system("clear") per liberare lo schermo del terminale prima dell'azione successiva. </p>

</div>
</div>
<a id="aa37f9cbe06f2e7203172e4f37b8c0a07" name="aa37f9cbe06f2e7203172e4f37b8c0a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37f9cbe06f2e7203172e4f37b8c0a07">&#9670;&#160;</a></span>select_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char select_pos </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: char</p>
<p>Parametri: nessuno</p>
<p>La funzione viene utilizzata per chiedere al giocatore se inserire la tessera a sinistra o a destra nel campo di gioco. Viene quindi chiesto di inserire il carattere D (destra) o S (sinistra) e viene ritornato il carattere ricevuto in input se valido altrimenti viene richiesto il rinserimento. </p>

</div>
</div>
<a id="a91ab112764167d32e08f3c9d8a7fc42c" name="a91ab112764167d32e08f3c9d8a7fc42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ab112764167d32e08f3c9d8a7fc42c">&#9670;&#160;</a></span>switch_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void switch_tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_tile.html">Tile</a> *</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: void</p>
<p>Parametri: <a class="el" href="struct_tile.html">Tile</a> *x</p>
<p>funzione che scambia l'ordine dei numeri all'interno di una tessera. Se <a class="el" href="struct_tile.html">Tile</a> *x era [xy], la funzione la trasforma in [yx]. </p>

</div>
</div>
<a id="ac15f9f890a419d2eea86e1f7b2f43afd" name="ac15f9f890a419d2eea86e1f7b2f43afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15f9f890a419d2eea86e1f7b2f43afd">&#9670;&#160;</a></span>tile_to_horizontal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * tile_to_horizontal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_tile.html">Tile</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: char*</p>
<p>Parametri: tessera t di tipo struct <a class="el" href="struct_tile.html">Tile</a>.</p>
<p>La funzione restituisce un puntatore ad un array di char di dimensione 4 che conterra la tessera selezionata per l'inserimento nella board in formato orizzontale. Viene allocato un char* 1*4 che conterra in posizione [0][1] il valore salvato in t.x ed in posizione [0][2] il valore salvato in t.y </p>

</div>
</div>
<a id="adf2f0668482407dcc36c58262d0727f7" name="adf2f0668482407dcc36c58262d0727f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2f0668482407dcc36c58262d0727f7">&#9670;&#160;</a></span>tile_to_vertical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** tile_to_vertical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_tile.html">Tile</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tipo: char**. la funzione restituisce doppio puntatore ad un array 2*2 di char che conterrà la tessera selezionata per l'inserimento nella board già in formato verticale.</p>
<p>Parametri: tessera di tipo struct <a class="el" href="struct_tile.html">Tile</a></p>
<p>Viene creato un char** 2*2 che conterra in posizione [0][1] il valore di t.x ed in posizione [1][0] il valore di t.y. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
